---
title: '–°–æ–∑–¥–∞–Ω–∏–µ RESTful API —Å Node.js –∏ Express'
description: '–ü–æ–ª–Ω–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ —Å–æ–∑–¥–∞–Ω–∏—é production-ready REST API —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Node.js, Express –∏ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø—Ä–∞–∫—Ç–∏–∫ 2024 –≥–æ–¥–∞.'
date: '2024-11-05'
coverImage: 'https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=1200&h=630&fit=crop'
author: '–°–µ—Ä–≥–µ–π –ö–æ–∑–ª–æ–≤'
tags: ['Node.js', 'Express', 'API', 'Backend']
categories: ['–û–±—É—á–µ–Ω–∏–µ', 'Backend']
published: true
---

## Why Node.js for APIs?

Node.js has become the go-to choice for building APIs due to its:

- **Non-blocking I/O**: Perfect for handling multiple concurrent requests
- **JavaScript everywhere**: Use the same language on frontend and backend
- **Rich ecosystem**: NPM provides packages for almost everything
- **Performance**: V8 engine makes it incredibly fast

## Setting Up the Project

Let's create a new Node.js project:

```bash
mkdir my-api
cd my-api
npm init -y
npm install express cors helmet morgan dotenv
npm install -D typescript @types/node @types/express ts-node nodemon
```

<Callout type="info">
We're using TypeScript for better type safety and developer experience.
</Callout>

## Project Structure

Organize your project like this:

```
my-api/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îî‚îÄ‚îÄ server.ts
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ tsconfig.json
```

## Creating the Server

```typescript
// src/server.ts
import express from 'express'
import cors from 'cors'
import helmet from 'helmet'
import morgan from 'morgan'

const app = express()
const PORT = process.env.PORT || 3000

// Middleware
app.use(express.json())
app.use(cors())
app.use(helmet())
app.use(morgan('dev'))

// Routes
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() })
})

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`)
})
```

## REST Principles

A RESTful API follows these principles:

1. **Stateless**: Each request contains all necessary information
2. **Resource-based**: URLs represent resources, not actions
3. **HTTP methods**: Use GET, POST, PUT, DELETE appropriately
4. **JSON**: Use JSON for request/response bodies

### HTTP Methods

| Method | Purpose | Example |
|--------|---------|---------|
| GET | Retrieve resources | `GET /api/users` |
| POST | Create resources | `POST /api/users` |
| PUT | Update resources | `PUT /api/users/1` |
| DELETE | Delete resources | `DELETE /api/users/1` |

<Callout type="warning" title="Idempotency">
PUT and DELETE should be idempotent - calling them multiple times should have the same effect as calling once.
</Callout>

## Creating Routes

```typescript
// src/routes/users.ts
import { Router } from 'express'
import { getAllUsers, getUser, createUser, updateUser, deleteUser } from '../controllers/users'

const router = Router()

router.get('/', getAllUsers)
router.get('/:id', getUser)
router.post('/', createUser)
router.put('/:id', updateUser)
router.delete('/:id', deleteUser)

export default router
```

## Controller Pattern

```typescript
// src/controllers/users.ts
import { Request, Response } from 'express'

export const getAllUsers = async (req: Request, res: Response) => {
  try {
    // Fetch from database
    const users = await db.users.findMany()
    res.json({ data: users })
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' })
  }
}

export const createUser = async (req: Request, res: Response) => {
  try {
    const user = await db.users.create({
      data: req.body
    })
    res.status(201).json({ data: user })
  } catch (error) {
    res.status(400).json({ error: 'Invalid request' })
  }
}
```

## Error Handling Middleware

```typescript
// src/middleware/errorHandler.ts
import { Request, Response, NextFunction } from 'express'

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error(err.stack)

  res.status(500).json({
    error: {
      message: err.message,
      ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
    }
  })
}
```

<Callout type="success">
Always use error handling middleware to catch unhandled errors gracefully!
</Callout>

## Validation

Use a validation library like Zod:

```typescript
import { z } from 'zod'

const userSchema = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  age: z.number().min(18).optional()
})

export const createUser = async (req: Request, res: Response) => {
  const result = userSchema.safeParse(req.body)

  if (!result.success) {
    return res.status(400).json({ error: result.error })
  }

  // Create user with validated data
  const user = await db.users.create({ data: result.data })
  res.status(201).json({ data: user })
}
```

## Best Practices

1. **Use environment variables** for configuration
2. **Implement rate limiting** to prevent abuse
3. **Add authentication** with JWT or OAuth
4. **Document your API** with OpenAPI/Swagger
5. **Version your API** (e.g., `/api/v1/users`)
6. **Use HTTPS** in production
7. **Log everything** for debugging

<Callout type="tip">
Consider using API Gateway patterns for microservices architectures!
</Callout>

## Conclusion

Building RESTful APIs with Node.js and Express is straightforward when you follow best practices. Focus on clear structure, error handling, and security to create production-ready APIs.

Happy coding! üöÄ
